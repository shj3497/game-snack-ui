/**
 * Generated by orval v7.8.0 🍺
 * Do not edit manually.
 * 핀플로우 프로모션: API
 * 핀플로우 프로모션: API 문서
 * OpenAPI spec version: 1.0
 */
import {useMutation, useQuery} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  CatchEventCheckResponse,
  CatchMiniGameEntryCreateRequest,
  CheckCatchEligibilityParams,
  CheckDrawEligibilityParams,
  CheckFindEligibilityParams,
  CheckRouletteEligibilityParams,
  DrawEventCheckResponse,
  DrawMiniGameEntryCreateRequest,
  EmptyResponse,
  EventAdPlacementInfoResponse,
  FindEventCheckResponse,
  FindMiniGameEntryCreateRequest,
  GiveRewardParams,
  RouletteEventCheckResponse,
  RouletteMiniGameEntryCreateRequest,
} from '.././model';

import {customAxios} from '../../custom-axios';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary ROULETTE(룰렛돌리기) 응모 저장
 */
export const saveRouletteMiniGameEntry = (
  publicEventId: string,
  rouletteMiniGameEntryCreateRequest: RouletteMiniGameEntryCreateRequest,
  options?: SecondParameter<typeof customAxios>,
  signal?: AbortSignal,
) => {
  return customAxios<EmptyResponse>(
    {
      url: `/api/events/roulette/${publicEventId}/entry`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: rouletteMiniGameEntryCreateRequest,
      signal,
    },
    options,
  );
};

export const getSaveRouletteMiniGameEntryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveRouletteMiniGameEntry>>,
    TError,
    {publicEventId: string; data: RouletteMiniGameEntryCreateRequest},
    TContext
  >;
  request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveRouletteMiniGameEntry>>,
  TError,
  {publicEventId: string; data: RouletteMiniGameEntryCreateRequest},
  TContext
> => {
  const mutationKey = ['saveRouletteMiniGameEntry'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveRouletteMiniGameEntry>>,
    {publicEventId: string; data: RouletteMiniGameEntryCreateRequest}
  > = (props) => {
    const {publicEventId, data} = props ?? {};

    return saveRouletteMiniGameEntry(publicEventId, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type SaveRouletteMiniGameEntryMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveRouletteMiniGameEntry>>
>;
export type SaveRouletteMiniGameEntryMutationBody =
  RouletteMiniGameEntryCreateRequest;
export type SaveRouletteMiniGameEntryMutationError = unknown;

/**
 * @summary ROULETTE(룰렛돌리기) 응모 저장
 */
export const useSaveRouletteMiniGameEntry = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveRouletteMiniGameEntry>>,
      TError,
      {publicEventId: string; data: RouletteMiniGameEntryCreateRequest},
      TContext
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveRouletteMiniGameEntry>>,
  TError,
  {publicEventId: string; data: RouletteMiniGameEntryCreateRequest},
  TContext
> => {
  const mutationOptions = getSaveRouletteMiniGameEntryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary FIND(찾기) 응모 저장
 */
export const saveFindMiniGameEntry = (
  publicEventId: string,
  findMiniGameEntryCreateRequest: FindMiniGameEntryCreateRequest,
  options?: SecondParameter<typeof customAxios>,
  signal?: AbortSignal,
) => {
  return customAxios<EmptyResponse>(
    {
      url: `/api/events/find/${publicEventId}/entry`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: findMiniGameEntryCreateRequest,
      signal,
    },
    options,
  );
};

export const getSaveFindMiniGameEntryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveFindMiniGameEntry>>,
    TError,
    {publicEventId: string; data: FindMiniGameEntryCreateRequest},
    TContext
  >;
  request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveFindMiniGameEntry>>,
  TError,
  {publicEventId: string; data: FindMiniGameEntryCreateRequest},
  TContext
> => {
  const mutationKey = ['saveFindMiniGameEntry'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveFindMiniGameEntry>>,
    {publicEventId: string; data: FindMiniGameEntryCreateRequest}
  > = (props) => {
    const {publicEventId, data} = props ?? {};

    return saveFindMiniGameEntry(publicEventId, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type SaveFindMiniGameEntryMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveFindMiniGameEntry>>
>;
export type SaveFindMiniGameEntryMutationBody = FindMiniGameEntryCreateRequest;
export type SaveFindMiniGameEntryMutationError = unknown;

/**
 * @summary FIND(찾기) 응모 저장
 */
export const useSaveFindMiniGameEntry = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveFindMiniGameEntry>>,
      TError,
      {publicEventId: string; data: FindMiniGameEntryCreateRequest},
      TContext
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveFindMiniGameEntry>>,
  TError,
  {publicEventId: string; data: FindMiniGameEntryCreateRequest},
  TContext
> => {
  const mutationOptions = getSaveFindMiniGameEntryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary DRAW(따라그리기) 응모 저장
 */
export const saveDrawMiniGameEntry = (
  publicEventId: string,
  drawMiniGameEntryCreateRequest: DrawMiniGameEntryCreateRequest,
  options?: SecondParameter<typeof customAxios>,
  signal?: AbortSignal,
) => {
  return customAxios<EmptyResponse>(
    {
      url: `/api/events/draw/${publicEventId}/entry`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: drawMiniGameEntryCreateRequest,
      signal,
    },
    options,
  );
};

export const getSaveDrawMiniGameEntryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveDrawMiniGameEntry>>,
    TError,
    {publicEventId: string; data: DrawMiniGameEntryCreateRequest},
    TContext
  >;
  request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveDrawMiniGameEntry>>,
  TError,
  {publicEventId: string; data: DrawMiniGameEntryCreateRequest},
  TContext
> => {
  const mutationKey = ['saveDrawMiniGameEntry'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveDrawMiniGameEntry>>,
    {publicEventId: string; data: DrawMiniGameEntryCreateRequest}
  > = (props) => {
    const {publicEventId, data} = props ?? {};

    return saveDrawMiniGameEntry(publicEventId, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type SaveDrawMiniGameEntryMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveDrawMiniGameEntry>>
>;
export type SaveDrawMiniGameEntryMutationBody = DrawMiniGameEntryCreateRequest;
export type SaveDrawMiniGameEntryMutationError = unknown;

/**
 * @summary DRAW(따라그리기) 응모 저장
 */
export const useSaveDrawMiniGameEntry = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveDrawMiniGameEntry>>,
      TError,
      {publicEventId: string; data: DrawMiniGameEntryCreateRequest},
      TContext
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveDrawMiniGameEntry>>,
  TError,
  {publicEventId: string; data: DrawMiniGameEntryCreateRequest},
  TContext
> => {
  const mutationOptions = getSaveDrawMiniGameEntryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 작업중..
 * @summary 응모 완료 후 리워드 지급 요청
 */
export const giveReward = (
  publicEventId: string,
  params: GiveRewardParams,
  options?: SecondParameter<typeof customAxios>,
  signal?: AbortSignal,
) => {
  return customAxios<EmptyResponse>(
    {
      url: `/api/events/complete/${publicEventId}`,
      method: 'POST',
      params,
      signal,
    },
    options,
  );
};

export const getGiveRewardMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof giveReward>>,
    TError,
    {publicEventId: string; params: GiveRewardParams},
    TContext
  >;
  request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof giveReward>>,
  TError,
  {publicEventId: string; params: GiveRewardParams},
  TContext
> => {
  const mutationKey = ['giveReward'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof giveReward>>,
    {publicEventId: string; params: GiveRewardParams}
  > = (props) => {
    const {publicEventId, params} = props ?? {};

    return giveReward(publicEventId, params, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type GiveRewardMutationResult = NonNullable<
  Awaited<ReturnType<typeof giveReward>>
>;

export type GiveRewardMutationError = unknown;

/**
 * @summary 응모 완료 후 리워드 지급 요청
 */
export const useGiveReward = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof giveReward>>,
      TError,
      {publicEventId: string; params: GiveRewardParams},
      TContext
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof giveReward>>,
  TError,
  {publicEventId: string; params: GiveRewardParams},
  TContext
> => {
  const mutationOptions = getGiveRewardMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary CATCH(잡기) 응모 저장
 */
export const saveCatchMiniGameEntry = (
  publicEventId: string,
  catchMiniGameEntryCreateRequest: CatchMiniGameEntryCreateRequest,
  options?: SecondParameter<typeof customAxios>,
  signal?: AbortSignal,
) => {
  return customAxios<EmptyResponse>(
    {
      url: `/api/events/catch/${publicEventId}/entry`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: catchMiniGameEntryCreateRequest,
      signal,
    },
    options,
  );
};

export const getSaveCatchMiniGameEntryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveCatchMiniGameEntry>>,
    TError,
    {publicEventId: string; data: CatchMiniGameEntryCreateRequest},
    TContext
  >;
  request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveCatchMiniGameEntry>>,
  TError,
  {publicEventId: string; data: CatchMiniGameEntryCreateRequest},
  TContext
> => {
  const mutationKey = ['saveCatchMiniGameEntry'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveCatchMiniGameEntry>>,
    {publicEventId: string; data: CatchMiniGameEntryCreateRequest}
  > = (props) => {
    const {publicEventId, data} = props ?? {};

    return saveCatchMiniGameEntry(publicEventId, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type SaveCatchMiniGameEntryMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveCatchMiniGameEntry>>
>;
export type SaveCatchMiniGameEntryMutationBody =
  CatchMiniGameEntryCreateRequest;
export type SaveCatchMiniGameEntryMutationError = unknown;

/**
 * @summary CATCH(잡기) 응모 저장
 */
export const useSaveCatchMiniGameEntry = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveCatchMiniGameEntry>>,
      TError,
      {publicEventId: string; data: CatchMiniGameEntryCreateRequest},
      TContext
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveCatchMiniGameEntry>>,
  TError,
  {publicEventId: string; data: CatchMiniGameEntryCreateRequest},
  TContext
> => {
  const mutationOptions = getSaveCatchMiniGameEntryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary ROULETTE(룰렛돌리기) 응모 가능 여부 확인
 */
export const checkRouletteEligibility = (
  publicEventId: string,
  params: CheckRouletteEligibilityParams,
  options?: SecondParameter<typeof customAxios>,
  signal?: AbortSignal,
) => {
  return customAxios<RouletteEventCheckResponse>(
    {
      url: `/api/events/roulette/${publicEventId}/check`,
      method: 'GET',
      params,
      signal,
    },
    options,
  );
};

export const getCheckRouletteEligibilityQueryKey = (
  publicEventId: string,
  params: CheckRouletteEligibilityParams,
) => {
  return [
    `/api/events/roulette/${publicEventId}/check`,
    ...(params ? [params] : []),
  ] as const;
};

export const getCheckRouletteEligibilityQueryOptions = <
  TData = Awaited<ReturnType<typeof checkRouletteEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckRouletteEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkRouletteEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCheckRouletteEligibilityQueryKey(publicEventId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof checkRouletteEligibility>>
  > = ({signal}) =>
    checkRouletteEligibility(publicEventId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!publicEventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof checkRouletteEligibility>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>};
};

export type CheckRouletteEligibilityQueryResult = NonNullable<
  Awaited<ReturnType<typeof checkRouletteEligibility>>
>;
export type CheckRouletteEligibilityQueryError = unknown;

export function useCheckRouletteEligibility<
  TData = Awaited<ReturnType<typeof checkRouletteEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckRouletteEligibilityParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkRouletteEligibility>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkRouletteEligibility>>,
          TError,
          Awaited<ReturnType<typeof checkRouletteEligibility>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCheckRouletteEligibility<
  TData = Awaited<ReturnType<typeof checkRouletteEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckRouletteEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkRouletteEligibility>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkRouletteEligibility>>,
          TError,
          Awaited<ReturnType<typeof checkRouletteEligibility>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
export function useCheckRouletteEligibility<
  TData = Awaited<ReturnType<typeof checkRouletteEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckRouletteEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkRouletteEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
/**
 * @summary ROULETTE(룰렛돌리기) 응모 가능 여부 확인
 */

export function useCheckRouletteEligibility<
  TData = Awaited<ReturnType<typeof checkRouletteEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckRouletteEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkRouletteEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCheckRouletteEligibilityQueryOptions(
    publicEventId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>};

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ROULETTE(룰렛돌리기) 응모 가능 여부 확인
 */
export const prefetchCheckRouletteEligibility = async <
  TData = Awaited<ReturnType<typeof checkRouletteEligibility>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  publicEventId: string,
  params: CheckRouletteEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkRouletteEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
): Promise<QueryClient> => {
  const queryOptions = getCheckRouletteEligibilityQueryOptions(
    publicEventId,
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary FIND(찾기) 응모 가능 여부 확인
 */
export const checkFindEligibility = (
  publicEventId: string,
  params: CheckFindEligibilityParams,
  options?: SecondParameter<typeof customAxios>,
  signal?: AbortSignal,
) => {
  return customAxios<FindEventCheckResponse>(
    {
      url: `/api/events/find/${publicEventId}/check`,
      method: 'GET',
      params,
      signal,
    },
    options,
  );
};

export const getCheckFindEligibilityQueryKey = (
  publicEventId: string,
  params: CheckFindEligibilityParams,
) => {
  return [
    `/api/events/find/${publicEventId}/check`,
    ...(params ? [params] : []),
  ] as const;
};

export const getCheckFindEligibilityQueryOptions = <
  TData = Awaited<ReturnType<typeof checkFindEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckFindEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkFindEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCheckFindEligibilityQueryKey(publicEventId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof checkFindEligibility>>
  > = ({signal}) =>
    checkFindEligibility(publicEventId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!publicEventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof checkFindEligibility>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>};
};

export type CheckFindEligibilityQueryResult = NonNullable<
  Awaited<ReturnType<typeof checkFindEligibility>>
>;
export type CheckFindEligibilityQueryError = unknown;

export function useCheckFindEligibility<
  TData = Awaited<ReturnType<typeof checkFindEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckFindEligibilityParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkFindEligibility>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkFindEligibility>>,
          TError,
          Awaited<ReturnType<typeof checkFindEligibility>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCheckFindEligibility<
  TData = Awaited<ReturnType<typeof checkFindEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckFindEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkFindEligibility>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkFindEligibility>>,
          TError,
          Awaited<ReturnType<typeof checkFindEligibility>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
export function useCheckFindEligibility<
  TData = Awaited<ReturnType<typeof checkFindEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckFindEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkFindEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
/**
 * @summary FIND(찾기) 응모 가능 여부 확인
 */

export function useCheckFindEligibility<
  TData = Awaited<ReturnType<typeof checkFindEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckFindEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkFindEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCheckFindEligibilityQueryOptions(
    publicEventId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>};

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary FIND(찾기) 응모 가능 여부 확인
 */
export const prefetchCheckFindEligibility = async <
  TData = Awaited<ReturnType<typeof checkFindEligibility>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  publicEventId: string,
  params: CheckFindEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkFindEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
): Promise<QueryClient> => {
  const queryOptions = getCheckFindEligibilityQueryOptions(
    publicEventId,
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary DRAW(따라그리기) 응모 가능 여부 확인
 */
export const checkDrawEligibility = (
  publicEventId: string,
  params: CheckDrawEligibilityParams,
  options?: SecondParameter<typeof customAxios>,
  signal?: AbortSignal,
) => {
  return customAxios<DrawEventCheckResponse>(
    {
      url: `/api/events/draw/${publicEventId}/check`,
      method: 'GET',
      params,
      signal,
    },
    options,
  );
};

export const getCheckDrawEligibilityQueryKey = (
  publicEventId: string,
  params: CheckDrawEligibilityParams,
) => {
  return [
    `/api/events/draw/${publicEventId}/check`,
    ...(params ? [params] : []),
  ] as const;
};

export const getCheckDrawEligibilityQueryOptions = <
  TData = Awaited<ReturnType<typeof checkDrawEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckDrawEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkDrawEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCheckDrawEligibilityQueryKey(publicEventId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof checkDrawEligibility>>
  > = ({signal}) =>
    checkDrawEligibility(publicEventId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!publicEventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof checkDrawEligibility>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>};
};

export type CheckDrawEligibilityQueryResult = NonNullable<
  Awaited<ReturnType<typeof checkDrawEligibility>>
>;
export type CheckDrawEligibilityQueryError = unknown;

export function useCheckDrawEligibility<
  TData = Awaited<ReturnType<typeof checkDrawEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckDrawEligibilityParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkDrawEligibility>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkDrawEligibility>>,
          TError,
          Awaited<ReturnType<typeof checkDrawEligibility>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCheckDrawEligibility<
  TData = Awaited<ReturnType<typeof checkDrawEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckDrawEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkDrawEligibility>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkDrawEligibility>>,
          TError,
          Awaited<ReturnType<typeof checkDrawEligibility>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
export function useCheckDrawEligibility<
  TData = Awaited<ReturnType<typeof checkDrawEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckDrawEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkDrawEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
/**
 * @summary DRAW(따라그리기) 응모 가능 여부 확인
 */

export function useCheckDrawEligibility<
  TData = Awaited<ReturnType<typeof checkDrawEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckDrawEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkDrawEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCheckDrawEligibilityQueryOptions(
    publicEventId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>};

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary DRAW(따라그리기) 응모 가능 여부 확인
 */
export const prefetchCheckDrawEligibility = async <
  TData = Awaited<ReturnType<typeof checkDrawEligibility>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  publicEventId: string,
  params: CheckDrawEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkDrawEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
): Promise<QueryClient> => {
  const queryOptions = getCheckDrawEligibilityQueryOptions(
    publicEventId,
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary CATCH(잡기) 응모 가능 여부 확인
 */
export const checkCatchEligibility = (
  publicEventId: string,
  params: CheckCatchEligibilityParams,
  options?: SecondParameter<typeof customAxios>,
  signal?: AbortSignal,
) => {
  return customAxios<CatchEventCheckResponse>(
    {
      url: `/api/events/catch/${publicEventId}/check`,
      method: 'GET',
      params,
      signal,
    },
    options,
  );
};

export const getCheckCatchEligibilityQueryKey = (
  publicEventId: string,
  params: CheckCatchEligibilityParams,
) => {
  return [
    `/api/events/catch/${publicEventId}/check`,
    ...(params ? [params] : []),
  ] as const;
};

export const getCheckCatchEligibilityQueryOptions = <
  TData = Awaited<ReturnType<typeof checkCatchEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckCatchEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkCatchEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCheckCatchEligibilityQueryKey(publicEventId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof checkCatchEligibility>>
  > = ({signal}) =>
    checkCatchEligibility(publicEventId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!publicEventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof checkCatchEligibility>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>};
};

export type CheckCatchEligibilityQueryResult = NonNullable<
  Awaited<ReturnType<typeof checkCatchEligibility>>
>;
export type CheckCatchEligibilityQueryError = unknown;

export function useCheckCatchEligibility<
  TData = Awaited<ReturnType<typeof checkCatchEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckCatchEligibilityParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkCatchEligibility>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkCatchEligibility>>,
          TError,
          Awaited<ReturnType<typeof checkCatchEligibility>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCheckCatchEligibility<
  TData = Awaited<ReturnType<typeof checkCatchEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckCatchEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkCatchEligibility>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkCatchEligibility>>,
          TError,
          Awaited<ReturnType<typeof checkCatchEligibility>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
export function useCheckCatchEligibility<
  TData = Awaited<ReturnType<typeof checkCatchEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckCatchEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkCatchEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
/**
 * @summary CATCH(잡기) 응모 가능 여부 확인
 */

export function useCheckCatchEligibility<
  TData = Awaited<ReturnType<typeof checkCatchEligibility>>,
  TError = unknown,
>(
  publicEventId: string,
  params: CheckCatchEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkCatchEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCheckCatchEligibilityQueryOptions(
    publicEventId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>};

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CATCH(잡기) 응모 가능 여부 확인
 */
export const prefetchCheckCatchEligibility = async <
  TData = Awaited<ReturnType<typeof checkCatchEligibility>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  publicEventId: string,
  params: CheckCatchEligibilityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkCatchEligibility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
): Promise<QueryClient> => {
  const queryOptions = getCheckCatchEligibilityQueryOptions(
    publicEventId,
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary 앱 별 이벤트에서 등록할 수 있는 광고 지면 목록 조회
 */
export const getEventAdPlacementInfo = (
  publicEventId: string,
  options?: SecondParameter<typeof customAxios>,
  signal?: AbortSignal,
) => {
  return customAxios<EventAdPlacementInfoResponse>(
    {url: `/api/events/ad-info/${publicEventId}`, method: 'GET', signal},
    options,
  );
};

export const getGetEventAdPlacementInfoQueryKey = (publicEventId: string) => {
  return [`/api/events/ad-info/${publicEventId}`] as const;
};

export const getGetEventAdPlacementInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
  TError = unknown,
>(
  publicEventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetEventAdPlacementInfoQueryKey(publicEventId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEventAdPlacementInfo>>
  > = ({signal}) =>
    getEventAdPlacementInfo(publicEventId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!publicEventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>};
};

export type GetEventAdPlacementInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEventAdPlacementInfo>>
>;
export type GetEventAdPlacementInfoQueryError = unknown;

export function useGetEventAdPlacementInfo<
  TData = Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
  TError = unknown,
>(
  publicEventId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
          TError,
          Awaited<ReturnType<typeof getEventAdPlacementInfo>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventAdPlacementInfo<
  TData = Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
  TError = unknown,
>(
  publicEventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
          TError,
          Awaited<ReturnType<typeof getEventAdPlacementInfo>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
export function useGetEventAdPlacementInfo<
  TData = Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
  TError = unknown,
>(
  publicEventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
/**
 * @summary 앱 별 이벤트에서 등록할 수 있는 광고 지면 목록 조회
 */

export function useGetEventAdPlacementInfo<
  TData = Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
  TError = unknown,
>(
  publicEventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEventAdPlacementInfoQueryOptions(
    publicEventId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>};

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary 앱 별 이벤트에서 등록할 수 있는 광고 지면 목록 조회
 */
export const prefetchGetEventAdPlacementInfo = async <
  TData = Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  publicEventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventAdPlacementInfo>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customAxios>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetEventAdPlacementInfoQueryOptions(
    publicEventId,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};
